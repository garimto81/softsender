<!--
  Soft Content Sender v11.15.0
  Build Time: 2025-10-18T15:37:10.434Z
  Build Mode: NORMAL

  ⚠️  AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
  Edit source files in src/ and run 'npm run build'
-->

<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
/* ============================================
   Design Tokens - Focus Mode UI System
   ============================================

   Purpose: 생방송 자막 시스템을 위한 디자인 토큰
   Based on: Think Hard 프레임워크 분석 결과
   Target: 모바일 퍼스트 (393px~768px)

   참고:
   - 인지심리학 기반 (Hick's Law, Miller's Law, Fitts's Law)
   - 생방송 환경 최적화 (스트레스 상황 대응)
   - Apple HIG 터치 가이드라인 (최소 48px, 권장 64px)

   ============================================ */

/* ============================================
   1. Color System
   ============================================ */

:root {
  /* --- Background --- */
  --color-bg: #0A0B0C;           /* 거의 검정 (눈 피로 최소화) */
  --color-surface: #131416;      /* 카드/패널 배경 */
  --color-surface-hover: #1C1D1F; /* hover 상태 */
  --color-border: #2A2B2C;       /* 구분선 (기존 유지) */

  /* --- Text --- */
  --color-text-primary: #FFFFFF;   /* 주요 텍스트 */
  --color-text-secondary: #A0A0A0; /* 보조 텍스트 */
  --color-text-disabled: #606060;  /* 비활성 텍스트 */

  /* --- Semantic Colors (신호등 체계) --- */
  --color-success: #10B981;  /* 녹색 - 성공/완료 */
  --color-warning: #F59E0B;  /* 주황 - 경고/주의 */
  --color-error: #EF4444;    /* 빨강 - 에러/긴급 */
  --color-info: #3B82F6;     /* 파랑 - 정보 */

  /* --- Mode Colors (직관적 연상) --- */
  --color-mode-pu: #3B82F6;      /* 파랑 - 일상 작업 (Player Update) */
  --color-mode-elim: #EF4444;    /* 빨강 - 긴급 상황 (Eliminate) */
  --color-mode-l3: #8B5CF6;      /* 보라 - 특별 작업 (Lower Third) */
  --color-mode-lb: #F59E0B;      /* 주황 - 순위 표시 (Leaderboard) */

  /* --- Accent --- */
  --color-accent: #06B6D4;       /* 시안 - 포커 테마, 주요 액션 */

  /* --- Legacy Aliases (기존 코드 호환) --- */
  --bg: #0E0F10;           /* 기존 배경색 유지 */
  --panel: #141516;        /* 기존 패널색 유지 */
  --panel2: #1B1C1D;       /* 기존 패널2 유지 */
  --border: #2A2B2C;       /* 기존 테두리 유지 */
  --txt: #F2F3F5;          /* 기존 텍스트 유지 */
  --sub: #B9C0CC;          /* 기존 보조 텍스트 유지 */
  --accent: #19D27C;       /* 기존 accent 색상 유지 (녹색) */
  --err: #FF6464;          /* 기존 에러 색상 유지 */
}

/* ============================================
   2. Typography System
   ============================================ */

:root {
  /* --- Type Scale (1.25 비율, Major Third) --- */
  --text-xs: 12px;   /* 보조 정보 (최소 크기) */
  --text-sm: 16px;   /* 레이블, iOS 줌 방지 최소값 */
  --text-base: 20px; /* 본문 (읽기 편안한 크기) */
  --text-lg: 25px;   /* 입력값 (명확한 가독성) */
  --text-xl: 31px;   /* 제목 */
  --text-2xl: 39px;  /* 미리보기 (최종 확인용) */

  /* --- Line Height --- */
  --leading-tight: 1.2;   /* 제목용 */
  --leading-normal: 1.5;  /* 본문 (기본) */
  --leading-loose: 1.8;   /* 긴 텍스트 */

  /* --- Font Weight --- */
  --font-normal: 400;
  --font-medium: 500;
  --font-bold: 700;
  --font-black: 900;

  /* --- Legacy Aliases (기존 값 유지) --- */
  --fs-xs: var(--text-xs);
  --fs-sm: 19px;              /* 기존 값 유지 */
  --fs-base: 24px;            /* 기존 값 유지 */
  --fs-lg: var(--text-lg);
  --fs-h: 32px;               /* 기존 값 유지 */
}

/* ============================================
   3. Spacing System (8px 기준)
   ============================================ */

:root {
  /* --- Base Unit: 8px --- */
  --space-1: 4px;   /* 0.5x - 최소 간격 */
  --space-2: 8px;   /* 1x - 기본 단위 */
  --space-3: 12px;  /* 1.5x - 패딩/마진 */
  --space-4: 16px;  /* 2x - 요소 간격 */
  --space-6: 24px;  /* 3x - 섹션 구분 */
  --space-8: 32px;  /* 4x - 큰 섹션 */
  --space-12: 48px; /* 6x - 블록 구분 */
  --space-16: 64px; /* 8x - 화면 구분 */

  /* --- Component Spacing --- */
  --touch-min: 48px;     /* Apple HIG 최소 터치 영역 */
  --touch-target: 64px;  /* 권장 터치 영역 (생방송 환경) */
  --input-height: 56px;  /* 입력 필드 높이 (편안한 터치) */

  /* --- Safe Area (iOS) --- */
  --safe-top: env(safe-area-inset-top, 0px);
  --safe-right: env(safe-area-inset-right, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-left: env(safe-area-inset-left, 0px);

  /* --- Legacy Aliases --- */
  --radius: 16px;        /* 기존 border-radius */
  --pad: 18px;           /* 기존 padding */
  --touch: var(--touch-target); /* 기존 터치 영역 */
}

/* ============================================
   4. Animation System
   ============================================ */

:root {
  /* --- Duration --- */
  --duration-instant: 0ms;      /* 즉시 (트랜지션 제거) */
  --duration-fast: 100ms;       /* 빠른 피드백 (입력 반응) */
  --duration-normal: 200ms;     /* 일반 전환 (버튼 hover) */
  --duration-slow: 400ms;       /* 강조 전환 (모드 변경) */

  /* --- Easing Functions --- */
  --ease-in: cubic-bezier(0.4, 0, 1, 1);          /* 가속 (시작 느림) */
  --ease-out: cubic-bezier(0, 0, 0.2, 1);         /* 감속 (끝 느림) */
  --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);    /* 가속+감속 */
  --ease-bounce: cubic-bezier(0.68, -0.55, 0.27, 1.55); /* 튕김 효과 */
}

/* ============================================
   5. Shadow System (Depth)
   ============================================ */

:root {
  /* --- Elevation --- */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.2);
  --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.3);

  /* --- Focus/Active State --- */
  --ring-offset: 2px;
  --ring-width: 4px;
  --ring-color: rgba(6, 182, 212, 0.3); /* accent 색상 기반 */
}

/* ============================================
   6. Z-Index Scale (Stacking Order)
   ============================================ */

:root {
  --z-base: 0;       /* 기본 레이어 */
  --z-dropdown: 10;  /* 드롭다운 */
  --z-sticky: 20;    /* 고정 헤더 */
  --z-modal: 30;     /* 모달 배경 */
  --z-toast: 40;     /* 토스트 메시지 */
  --z-tooltip: 50;   /* 툴팁 (최상위) */
}

/* ============================================
   7. Breakpoints (Mobile First)
   ============================================ */

:root {
  --bp-mobile: 393px;   /* iPhone 14 Pro 기준 */
  --bp-tablet: 768px;   /* iPad 기준 */
  --bp-desktop: 1024px; /* Desktop 기준 */
}

/* ============================================
   8. Component-Specific Tokens
   ============================================ */

:root {
  /* --- Button --- */
  --btn-height: var(--touch-target);      /* 64px */
  --btn-padding-x: var(--space-6);        /* 24px */
  --btn-font-size: var(--text-base);      /* 20px */
  --btn-font-weight: var(--font-black);   /* 900 */
  --btn-border-radius: var(--radius);     /* 16px */

  /* --- Input --- */
  --input-height: var(--touch-target);    /* 64px */
  --input-padding-x: var(--pad);          /* 18px */
  --input-font-size: var(--text-base);    /* 20px */
  --input-border-radius: var(--radius);   /* 16px */
  --input-border-width: 1px;

  /* --- Toast --- */
  --toast-min-width: 280px;
  --toast-max-width: 90vw;
  --toast-padding: 12px 16px;
  --toast-border-radius: 14px;
}

/* ============================================
   9. Utility Classes (Future Use)
   ============================================ */

/*
  Note: 현재는 토큰만 정의, 실제 클래스는 v11에서 추가 예정

  예시:
  .text-primary { color: var(--color-text-primary); }
  .bg-surface { background: var(--color-surface); }
  .p-4 { padding: var(--space-4); }
*/

/* ============================================
   10. Print / Dark Mode (Future Use)
   ============================================ */

/*
  Note: 현재는 다크 모드 기본값만 제공
  라이트 모드는 사용자 요청 시 추가 예정
*/

/* ============================================
   11. Performance Optimizations
   ============================================ */

:root {
  /* GPU 가속 활성화 */
  --transform-gpu: translateZ(0);

  /* 텍스트 렌더링 최적화 */
  --text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}


/* ============================================
   Legacy Styles (Design Tokens 기반)
   ============================================
   Note: 색상/타이포/공간 변수는 design-tokens.css에 정의됨
   여기서는 레이아웃/컴포넌트 스타일만 관리
   ============================================ */

html,body{background:var(--bg); color:var(--txt); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; font-size:var(--fs-base); margin:0; overflow:hidden; height:100vh;}
.wrap{max-width:980px;margin:0 auto;padding:6px 10px 50px; height:100vh; overflow-y:auto; box-sizing:border-box;}
header{display:flex;justify-content:space-between;align-items:flex-end;margin:2px 0 4px;}
h1{font-size:1.1em;margin:2px 0;}
#status{font-size:var(--fs-sm);color:#9fe7cc;}

.field{margin:5px 0;}
label{display:block;margin:2px 0 3px;color:var(--sub);font-size:0.75em;}
input,select,textarea{
  width:100%; background:var(--panel); color:var(--txt); border:1px solid var(--border);
  border-radius:12px; padding:0 14px; height:44px; box-sizing:border-box; font-size:0.9em;
}
textarea{min-height:90px; padding:10px 14px; white-space:pre-wrap; line-height:1.2;}

.row{display:grid; gap:8px;}
.row.two{grid-template-columns:1fr 1fr;}
.row.three{grid-template-columns:1fr 1fr 1fr;}

.tabs{display:flex;gap:6px;margin:8px 0;}
.tabs button{flex:1;height:40px;border-radius:10px;border:1px solid var(--border);background:var(--panel2);color:#0b1d14;background:linear-gradient(0deg,#19D27C,#19D27C);opacity:.85;font-size:0.85em;}
.tabs button.active{opacity:1;}
.btn{height:44px;padding:0 14px;border-radius:12px;border:1px solid var(--border);font-weight:800;font-size:0.9em;}
.btn.primary{background:var(--accent);color:#0b1d14;}
.btn.ghost{background:var(--panel2);color:#fff;}

.muted{color:var(--sub);font-size:var(--fs-sm);}
#toast{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;background:var(--panel2);color:#fff;padding:12px 16px;border-radius:14px;border:1px solid var(--border);opacity:0;pointer-events:none;z-index:10;}
#toast.show{opacity:1;transition:opacity .15s;}
#toast.err{border-color:var(--err);color:#ffdada;}

/* 로딩 오버레이 */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(11, 29, 20, 0.95);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  backdrop-filter: blur(4px);
}

.loading-content {
  text-align: center;
  padding: 40px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  max-width: 400px;
  width: 90%;
}

.spinner {
  width: 50px;
  height: 50px;
  margin: 0 auto 20px;
  border: 4px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.loading-message {
  font-size: 1.1em;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 12px;
}

.loading-details {
  font-size: 0.9em;
  color: var(--sub);
  line-height: 1.5;
  white-space: pre-line;
  min-height: 40px;
}

.lb-row{display:grid; grid-template-columns: 1.6fr 1fr; gap:10px; align-items:center;}
.lb-list{display:flex; flex-direction:column; gap:10px;}

/* 배치 빌더 최적화 */
details > summary {
  list-style: none;
}
details > summary::-webkit-details-marker {
  display: none;
}
details[open] > summary {
  background: var(--panel2) !important;
}

  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Soft Content Sender</h1>
      <div class="muted" style="font-size:0.75em; margin-top:-4px;">v11.15.0 (2025-01-17)</div>
    </div>
    <div id="status">로딩중…</div>
  </header>

  <!-- 시트ID 오버라이드 -->
  <section class="field">
    <label>Sheet IDs</label>
    <div class="row two">
      <input id="cueId" placeholder="CUE Sheet ID(옵션)" />
      <input id="typeId" placeholder="TYPE Sheet ID(옵션)" />
    </div>
    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:10px;">
      <button class="btn ghost" id="btnSaveIds">ID 저장</button>
      <button class="btn ghost" id="btnClearIds">ID 초기화</button>
    </div>
    <div class="muted" id="idsHint" style="margin-top:6px;"></div>
  </section>

  <section class="field">
    <div class="row two">
      <div class="field">
        <label>행 선택(시간)</label>
        <div style="display:flex;gap:12px;align-items:center;">
          <input id="chkAuto" type="checkbox" checked style="width:auto;height:auto;transform:scale(1.4);" />
          <span class="muted">현재 시각 자동 선택</span>
        </div>
      </div>
      <div class="field">
        <label>시간 드롭다운(±20분)</label>
        <select id="selTime"><option value="">(미선택: 현재시각)</option></select>
      </div>
    </div>
  </section>

  <section class="field">
    <div class="row two">
      <div class="field">
        <label>파일명(전송 전 수정 가능) — 형식: <b>HHmm_name_mode</b></label>
        <input id="fileName" placeholder="예: 1742_John_Doe_PU" />
      </div>
      <div class="field">
        <label>모드</label>
        <div class="tabs">
          <button id="tabPU" class="active">플레이어 업데이트(PU)</button>
          <button id="tabELIM">플레이어 탈락(ELIM)</button>
          <button id="tabL3">플레이어 소개(L3)</button>
        </div>
      </div>
    </div>
  </section>

  <section class="field">
    <div class="field">
      <label>테이블 선택</label>
      <select id="selRoomTable"><option value="">-</option></select>
    </div>

    <div class="field">
      <label>좌석 선택</label>
      <select id="selSeat"><option value="">좌석 선택</option></select>
    </div>

    <div class="field" id="singleFields">
      <label>국가 코드 (2자리)</label>
      <input id="countryCode" placeholder="예: US, KR" readonly />
    </div>
  </section>

  <!-- PU -->
  <section id="panelPU" class="field">
    <div class="row two">
      <div class="field">
        <label>칩스택(쉼표 포함) *</label>
        <input id="stackAmt" placeholder="예: 1,234,000" inputmode="numeric" />
      </div>
      <div class="field">
        <label>Big Blind(정수) *</label>
        <input id="bigBlind" placeholder="예: 20000" inputmode="numeric" />
      </div>
    </div>
    <div class="row two">
      <div class="field">
        <label>계산된 BB (자동, 반올림)</label>
        <input id="stackBBView" readonly placeholder="예: 62BB" />
      </div>
      <input id="stackBB" type="hidden" />
    </div>
  </section>


  <!-- ELIM -->
  <section id="panelELIM" class="field" style="display:none;">
    <p class="muted">"이름 / 국기<br>ELIMINATED" 형식으로 J셀에 추가됩니다.</p>
  </section>

  <!-- L3 -->
  <section id="panelL3" class="field" style="display:none;">
    <p class="muted">"프로필 자막" + 이름 2줄이 J셀에 추가됩니다.</p>
  </section>


  <!-- 액션 버튼 (입력 직후 바로 처리) -->
  <section class="field" style="display:flex;gap:12px;justify-content:flex-end;align-items:center;">
    <button class="btn ghost" id="btnAddToBatch" style="display:none;">
      ➕ 배치에 추가
    </button>
    <button class="btn primary" id="btnSend" style="min-width:200px;">전송</button>
  </section>

  <!-- 배치 리스트 (항목 있을 때만 표시) -->
  <section id="batchSection" class="field" style="display:none; background:var(--panel2); padding:var(--pad); border-radius:var(--radius); border:2px solid var(--accent);">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
      <label style="margin:0;">📦 배치 대기 중 (<span id="batchCount">0</span>건)</label>
      <button class="btn ghost" id="btnClearBatch" style="height:auto; padding:8px 14px; font-size:0.9em;">
        🗑️ 전체 삭제
      </button>
    </div>

    <!-- 배치 리스트 -->
    <div id="batchList" style="max-height:250px; overflow-y:auto; -webkit-overflow-scrolling:touch;">
      <!-- 동적 생성 -->
    </div>
  </section>

  <!-- 미리보기 (통합) -->
  <section class="field">
    <label id="previewLabel">미리보기</label>
    <textarea id="preview" readonly></textarea>
  </section>

  <section style="margin-top:12px;">
    <div class="muted" id="footerInfo"></div>
  </section>
</div>

<div id="toast"></div>

<!-- 로딩 오버레이 -->
<div id="loadingOverlay" class="loading-overlay">
  <div class="loading-content">
    <div class="spinner"></div>
    <div id="loadingMessage" class="loading-message">로딩 중...</div>
    <div id="loadingDetails" class="loading-details"></div>
  </div>
</div>

<script>
  // 상수 정의
const CONSTANTS = {
  TOAST_DURATION: 1800,
  DEFAULT_SEAT_INDEX: 1,
  DEBOUNCE_DELAY: 300,
  MODES: {
    PU: 'PU',
    ELIM: 'ELIM',
    L3: 'L3'
  },
  DISPLAY: {
    GRID: 'grid',
    BLOCK: 'block',
    NONE: 'none'
  }
};

// localStorage 키 (Sheet ID 백업용)
const LS_KEYS = {
  CUE: 'SCS_CUE_ID',
  TYPE: 'SCS_TYPE_ID'
};

const state = {
  mode: CONSTANTS.MODES.PU,
  tz: 'Asia/Seoul',
  typeRows: [],
  byRoom: {},
  byRoomTable: {},
  tableList: [],     // Room+Table 통합 목록
  timeCenter: '',
  cueId: '',
  typeId: '',
  batch: []          // 배치 전송용 배열
};

  /* ===== 통합 로딩 관리자 (Unified Loading Manager) ===== */

/**
 * 로딩 상태 관리 및 사용자 실수 방지
 *
 * 기능:
 * 1. 전역 로딩 상태 추적
 * 2. 중복 요청 방지 (한 번에 하나의 작업만)
 * 3. UI 비활성화 (버튼, 입력 필드 등)
 * 4. 진행 상황 표시
 * 5. 에러 처리 및 복구
 */

const LoadingManager = {
  // 상태
  isLoading: false,
  currentOperation: null,
  disabledElements: [],

  /**
   * 로딩 시작
   * @param {string} operation - 작업 이름 (예: 'INIT', 'SEND', 'SAVE_IDS')
   * @param {string} message - 로딩 메시지
   * @param {string} details - 상세 정보 (선택)
   */
  start(operation, message, details = '') {
    // 중복 요청 방지
    if (this.isLoading) {
      console.warn(`⚠️ [LoadingManager] 작업 중복 차단: ${this.currentOperation} → ${operation}`);
      return false;
    }

    this.isLoading = true;
    this.currentOperation = operation;

    // 로딩 오버레이 표시
    showLoading(message, details);

    // UI 비활성화
    this.disableUI();

    // 상태 업데이트
    setStatus('작업 중…');

    console.log(`🔄 [LoadingManager] 시작: ${operation}`);
    return true;
  },

  /**
   * 로딩 진행 상황 업데이트
   * @param {string} message - 업데이트 메시지
   * @param {string} details - 상세 정보 (선택)
   */
  update(message, details = '') {
    if (!this.isLoading) {
      console.warn('⚠️ [LoadingManager] 로딩 중이 아닌데 update 호출됨');
      return;
    }

    updateLoading(message, details);
    console.log(`📊 [LoadingManager] 진행: ${message}`);
  },

  /**
   * 로딩 종료 (성공)
   * @param {string} message - 완료 메시지 (선택)
   */
  success(message = '') {
    if (!this.isLoading) {
      console.warn('⚠️ [LoadingManager] 로딩 중이 아닌데 success 호출됨');
      return;
    }

    console.log(`✅ [LoadingManager] 성공: ${this.currentOperation}`);

    // 짧은 딜레이 후 종료 (사용자가 완료 메시지 확인 가능)
    setTimeout(() => {
      hideLoading();
      this.enableUI();
      setStatus('준비됨');

      if (message) {
        toast(message, true);
      }

      this.reset();
    }, 300);
  },

  /**
   * 로딩 종료 (에러)
   * @param {string} errorMsg - 에러 메시지
   * @param {boolean} showToast - 토스트 표시 여부 (기본: true)
   */
  error(errorMsg, showToast = true) {
    if (!this.isLoading) {
      console.warn('⚠️ [LoadingManager] 로딩 중이 아닌데 error 호출됨');
      return;
    }

    console.error(`❌ [LoadingManager] 에러: ${this.currentOperation} - ${errorMsg}`);

    hideLoading();
    this.enableUI();
    setStatus('에러');

    if (showToast) {
      toast(`❌ ${errorMsg}`, false);
    }

    this.reset();
  },

  /**
   * 상태 초기화
   */
  reset() {
    this.isLoading = false;
    this.currentOperation = null;
  },

  /**
   * UI 비활성화 (버튼, 입력 필드 등)
   */
  disableUI() {
    // 비활성화할 요소 선택
    const selectors = [
      'button',
      'input:not([type="hidden"])',
      'select',
      'textarea'
    ];

    selectors.forEach(selector => {
      document.querySelectorAll(selector).forEach(el => {
        if (!el.disabled) {
          el.disabled = true;
          this.disabledElements.push(el);
        }
      });
    });

    console.log(`🔒 [LoadingManager] UI 비활성화: ${this.disabledElements.length}개 요소`);
  },

  /**
   * UI 활성화
   */
  enableUI() {
    this.disabledElements.forEach(el => {
      el.disabled = false;
    });

    console.log(`🔓 [LoadingManager] UI 활성화: ${this.disabledElements.length}개 요소`);
    this.disabledElements = [];
  },

  /**
   * 로딩 중인지 확인
   * @returns {boolean}
   */
  isActive() {
    return this.isLoading;
  },

  /**
   * 현재 작업 가져오기
   * @returns {string|null}
   */
  getCurrentOperation() {
    return this.currentOperation;
  }
};

/**
 * 래퍼 함수: google.script.run 호출 시 자동 로딩 처리
 *
 * @param {string} operation - 작업 이름
 * @param {string} loadingMessage - 로딩 메시지
 * @param {Function} serverFunction - 서버 함수 (google.script.run.xxx)
 * @param {Object} callbacks - 콜백 함수들
 *   - onSuccess: 성공 시 콜백
 *   - onError: 에러 시 콜백 (선택)
 *   - onComplete: 완료 시 콜백 (선택)
 * @param {Array} args - 서버 함수 인자들
 *
 * @example
 * withLoading('SAVE_IDS', 'ID 저장 중...',
 *   google.script.run.saveUserPreference,
 *   {
 *     onSuccess: (res) => {
 *       if (res.ok) {
 *         LoadingManager.success('저장 완료');
 *       } else {
 *         LoadingManager.error(res.error);
 *       }
 *     }
 *   },
 *   [cueId, typeId]
 * );
 */
function withLoading(operation, loadingMessage, serverFunction, callbacks, args = []) {
  // 중복 요청 차단
  if (!LoadingManager.start(operation, loadingMessage)) {
    toast('⚠️ 이전 작업이 진행 중입니다. 완료 후 다시 시도하세요.', false);
    return;
  }

  // 서버 호출
  const runner = google.script.run
    .withSuccessHandler(res => {
      if (callbacks.onSuccess) {
        callbacks.onSuccess(res);
      }
      if (callbacks.onComplete) {
        callbacks.onComplete(res);
      }
    })
    .withFailureHandler(err => {
      const errorMsg = err?.message || err || 'unknown';

      if (callbacks.onError) {
        callbacks.onError(errorMsg);
      } else {
        LoadingManager.error(`서버 오류: ${errorMsg}`);
      }

      if (callbacks.onComplete) {
        callbacks.onComplete(null, errorMsg);
      }
    });

  // 함수 호출
  const funcName = serverFunction.toString().match(/\.(\w+)$/)?.[1] || 'unknown';
  runner[funcName](...args);
}

/**
 * 작업 중 사용자 실수 방지 (페이지 이탈 경고)
 */
window.addEventListener('beforeunload', (e) => {
  if (LoadingManager.isActive()) {
    e.preventDefault();
    e.returnValue = '작업이 진행 중입니다. 페이지를 나가시겠습니까?';
    return e.returnValue;
  }
});

  function toast(msg, ok=true){
  const t=document.getElementById('toast');
  t.textContent=msg; t.className='show'+(ok?'':' err');
  setTimeout(()=>t.className='', CONSTANTS.TOAST_DURATION);
}
function setStatus(s){ document.getElementById('status').textContent=s; }

/* ===== 로딩 오버레이 관리 ===== */
function showLoading(message, details){
  const overlay = document.getElementById('loadingOverlay');
  const msgEl = document.getElementById('loadingMessage');
  const detailsEl = document.getElementById('loadingDetails');

  msgEl.textContent = message || '로딩 중...';
  detailsEl.textContent = details || '';
  overlay.style.display = 'flex';
}

function updateLoading(message, details){
  const msgEl = document.getElementById('loadingMessage');
  const detailsEl = document.getElementById('loadingDetails');

  if (message) msgEl.textContent = message;
  if (details) detailsEl.textContent = details;
}

function hideLoading(){
  const overlay = document.getElementById('loadingOverlay');
  overlay.style.display = 'none';
}

/* ===== Sheet ID 저장/초기화 (Properties Service 사용) ===== */
function loadIdsFromLocal(){
  // 서버에서 사용자별 저장된 ID 로드 (localStorage는 백업용)
  const localCue = localStorage.getItem(LS_KEYS.CUE) || '';
  const localType = localStorage.getItem(LS_KEYS.TYPE) || '';

  // 임시로 로컬 값 표시 (서버 응답 전)
  if (localCue) document.getElementById('cueId').value = localCue;
  if (localType) document.getElementById('typeId').value = localType;
  state.cueId = localCue;
  state.typeId = localType;
  renderIdsHint();
}

function saveIds(){
  const cue = document.getElementById('cueId').value.trim();
  const type = document.getElementById('typeId').value.trim();

  // 로딩 시작
  if (!LoadingManager.start('SAVE_IDS', 'Sheet ID 저장 중...', '서버에 영구 저장합니다...')) {
    return;
  }

  // 서버에 저장 (영구 저장)
  google.script.run
    .withSuccessHandler(res => {
      if (res?.ok) {
        // localStorage에도 백업 저장
        if (cue) localStorage.setItem(LS_KEYS.CUE, cue); else localStorage.removeItem(LS_KEYS.CUE);
        if (type) localStorage.setItem(LS_KEYS.TYPE, type); else localStorage.removeItem(LS_KEYS.TYPE);

        state.cueId = cue;
        state.typeId = type;
        renderIdsHint();
        LoadingManager.success('✅ ID 저장 완료 (서버에 영구 저장됨)');

        // 저장 후 시트 재로드
        setTimeout(() => reloadSheets(), 500);
      } else {
        LoadingManager.error('저장 실패: ' + (res?.error || 'unknown'));
      }
    })
    .withFailureHandler(err => {
      LoadingManager.error('서버 오류: ' + (err?.message || err));
    })
    .saveUserPreference(cue, type);
}

// 자동 저장 함수 (입력 필드 변경 시)
function autoSaveIds(){
  const cue = document.getElementById('cueId').value.trim();
  const type = document.getElementById('typeId').value.trim();

  // localStorage에 임시 저장
  if (cue) localStorage.setItem(LS_KEYS.CUE, cue); else localStorage.removeItem(LS_KEYS.CUE);
  if (type) localStorage.setItem(LS_KEYS.TYPE, type); else localStorage.removeItem(LS_KEYS.TYPE);

  state.cueId = cue;
  state.typeId = type;
  renderIdsHint();

  // 서버에도 자동 저장 (비동기)
  google.script.run
    .withSuccessHandler(() => {
      // 조용히 성공 (토스트 메시지 없음)
    })
    .saveUserPreference(cue, type);
}

function clearIds(){
  // 로딩 시작
  if (!LoadingManager.start('CLEAR_IDS', 'Sheet ID 초기화 중...', '기본값으로 되돌립니다...')) {
    return;
  }

  // 서버에서 삭제
  google.script.run
    .withSuccessHandler(res => {
      if (res?.ok) {
        // localStorage도 초기화
        localStorage.removeItem(LS_KEYS.CUE);
        localStorage.removeItem(LS_KEYS.TYPE);

        state.cueId = '';
        state.typeId = '';
        document.getElementById('cueId').value = '';
        document.getElementById('typeId').value = '';
        renderIdsHint();
        LoadingManager.success('✅ ID 초기화 완료 (기본값 사용)');

        // 초기화 후 시트 재로드
        setTimeout(() => reloadSheets(), 500);
      } else {
        LoadingManager.error('초기화 실패: ' + (res?.error || 'unknown'));
      }
    })
    .withFailureHandler(err => {
      LoadingManager.error('서버 오류: ' + (err?.message || err));
    })
    .clearUserPreference();
}

function renderIdsHint(){
  const c = state.cueId ? `CUE=${state.cueId}` : 'CUE=기본값';
  const t = state.typeId? `TYPE=${state.typeId}`: 'TYPE=기본값';
  document.getElementById('idsHint').textContent = `현재 사용 중: ${c} | ${t}`;
}

/* 인덱싱 */
function indexTypeRows(rows){
  state.byRoom={}; state.byRoomTable={}; state.tableList=[];
  rows.forEach(r=>{
    (state.byRoom[r.room] ||= []).push(r);
    const key = r.room + '|' + r.tno;
    (state.byRoomTable[key] ||= []).push(r);
  });

  // Room+Table 통합 목록 생성
  Object.keys(state.byRoomTable).forEach(key => {
    const [room, tno] = key.split('|');
    const tname = state.byRoomTable[key][0]?.tname || '';
    state.tableList.push({
      key,
      label: tname ? `${room} - ${tname} (Table ${tno})` : `${room} - Table ${tno}`,
      room,
      tno
    });
  });

  // 정렬: Room → Table No.
  state.tableList.sort((a,b) => {
    if (a.room !== b.room) return a.room.localeCompare(b.room);
    return Number(a.tno) - Number(b.tno);
  });
}
function normSeat(s){
  const t = String(s||'').trim();
  if(!t) return '';
  // "seat 8", "Seat8", "#8", "08" 등 모두 처리
  const n = t.replace(/\s/g,'').replace(/^#?/,'').replace(/^seat/i, '').replace(/^0+/, '');
  return n ? '#'+n : '';
}

/* 플레이어 조회 헬퍼 함수 */
function findPlayerBySeat(key, seat) {
  if (!key || !seat) return null;
  const arr = state.byRoomTable[key] || [];
  return arr.find(r => normSeat(r.seat) === normSeat(seat));
}

/* ===== UI 채우기 ===== */
function fillRoomTables(){
  const sel = document.getElementById('selRoomTable');
  sel.innerHTML = '<option value="">-</option>';

  // 키 플레이어 정보를 포함한 테이블 리스트 생성
  const tablesWithKeyPlayerInfo = state.tableList.map(t => {
    const playersAtTable = state.byRoomTable[t.key] || [];
    const hasKeyPlayer = playersAtTable.some(p => p.keyPlayer);
    return {
      ...t,
      hasKeyPlayer,
      keyPlayerIcon: hasKeyPlayer ? ' ⭐' : ''
    };
  });

  // 키 플레이어가 있는 테이블을 최상단에 배치
  const sortedTables = tablesWithKeyPlayerInfo.sort((a, b) => {
    if (a.hasKeyPlayer && !b.hasKeyPlayer) return -1;
    if (!a.hasKeyPlayer && b.hasKeyPlayer) return 1;
    return 0; // 같은 그룹 내에서는 원래 순서 유지
  });

  const fragment = document.createDocumentFragment();
  sortedTables.forEach(t => {
    const o = document.createElement('option');
    o.value = t.key;
    o.textContent = t.label + t.keyPlayerIcon;
    fragment.appendChild(o);
  });
  sel.appendChild(fragment);

  if (sel.options.length > 1) sel.selectedIndex = CONSTANTS.DEFAULT_SEAT_INDEX;
  fillSeats();
}

function fillSeats(){
  const key = document.getElementById('selRoomTable').value;
  const selSeat = document.getElementById('selSeat');
  const prevSeat = selSeat.value;

  selSeat.innerHTML = '<option value="">좌석 선택</option>';

  if (!key) return;

  const arr = state.byRoomTable[key] || [];

  // Seat 드롭다운: "#1 - John Doe ⭐" 형식 (KeyPlayer 표시)
  console.log(`📋 [fillSeats] 테이블 ${key}: 전체 ${arr.length}명`);
  console.log(`📋 원본 좌석:`, arr.map(r => r.seat));

  const seats = [...new Set(arr.map(r => normSeat(r.seat)))]
    .filter(s => s) // 빈 값 제거
    .sort((a,b) => Number(a.replace('#','')) - Number(b.replace('#','')));

  console.log(`📋 정규화된 좌석 (${seats.length}개):`, seats);

  const fragment = document.createDocumentFragment();
  seats.forEach(s => {
    const player = findPlayerBySeat(key, s);
    const o = document.createElement('option');
    o.value = s;

    // 디버깅: KeyPlayer 필드 확인
    if (player) {
      console.log(`🎯 좌석 ${s}:`, {
        player: player.player,
        keyPlayer: player.keyPlayer,
        rawData: player
      });
    }

    // KeyPlayer인 경우 ⭐ 표시 추가
    const keyPlayerIcon = player?.keyPlayer ? ' ⭐' : '';
    o.textContent = `${s} - ${player?.player || ''}${keyPlayerIcon}`;

    fragment.appendChild(o);
  });
  selSeat.appendChild(fragment);

  const idx = seats.indexOf(prevSeat);
  selSeat.selectedIndex = idx >= 0 ? idx + CONSTANTS.DEFAULT_SEAT_INDEX : (seats.length > 0 ? CONSTANTS.DEFAULT_SEAT_INDEX : 0);

  applyPickFromSeat();
  rebuildFileName();
}

function applyPickFromSeat(){
  const key = document.getElementById('selRoomTable').value;
  const seat = document.getElementById('selSeat').value;
  const pick = findPlayerBySeat(key, seat);

  if (pick){
    document.getElementById('countryCode').value = pick.nat || '';
  }
  rebuildPreview();
  rebuildFileName();
}

/* 시간 옵션 */
function fillTimes(list, center){
  const sel = document.getElementById('selTime');
  sel.innerHTML = '<option value="">(미선택: 현재시각)</option>';

  const fragment = document.createDocumentFragment();
  list.forEach(v=>{
    const o=document.createElement('option');
    o.value=v; o.textContent = (v===center)? `${v}  ← 현재` : v;
    fragment.appendChild(o);
  });
  sel.appendChild(fragment);
}

/* 파일명 */
function hhmmFromTimeStr(t){ return (t||'').replace(':',''); }
function rebuildFileName(){
  const mode   = state.mode;
  const key    = document.getElementById('selRoomTable').value;
  const tno    = key ? key.split('|')[1] : '';
  const picked = document.getElementById('selTime').value;
  const hhmm   = hhmmFromTimeStr( picked || (state.timeCenter||'').slice(0,5) );

  let nameForMode;
  let modeData = {};

  if (mode === CONSTANTS.MODES.LEADERBOARD) {
    nameForMode = document.getElementById('lbTableLabel').value || ('Table'+tno);
  } else {
    const player = getSelectedPlayer();
    nameForMode = player ? player.player : 'Player';

    // PU 모드: 칩수 + BB
    if (mode === CONSTANTS.MODES.PU) {
      const chipCount = parseIntClean(document.getElementById('stackAmt').value);
      const bb = document.getElementById('stackBB').value;
      modeData = { chipCount, bb };
    }

    // ELIM 모드: 빈 객체 (필드 없음)
    if (mode === CONSTANTS.MODES.ELIM) {
      modeData = {};
    }

    // L3 모드: 프로필
    if (mode === CONSTANTS.MODES.L3) {
      modeData = { profileType: 'Profile' };
    }
  }

  // BATCH 모드: 개수
  if (state.batch.length > 0) {
    modeData.count = state.batch.length;
  }

  google.script.run.withSuccessHandler(name=>{
    document.getElementById('fileName').value = name;
  }).buildFileName(mode, hhmm, tno, nameForMode, modeData);
}

/* 숫자 유틸 */
function parseIntClean(s){ const n = Number(String(s||'').replace(/[^0-9]/g,'')); return isNaN(n)?0:Math.round(n); }
function comma(n){ return Number(n||0).toLocaleString('en-US'); }

/* 디바운싱 유틸 */
function debounce(func, delay) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => func(...args), delay);
  };
}

/* 입력창 실시간 콤마 포맷 */
function formatInputWithComma(el){
  const v = parseIntClean(el.value);
  el.value = v ? comma(v) : '';
}

/* PU: BB(반올림) */
function computeBB(){
  const amt = parseIntClean(document.getElementById('stackAmt').value);
  const bb  = parseIntClean(document.getElementById('bigBlind').value);
  const res = (amt>0 && bb>0) ? Math.round(amt / bb) : '';
  document.getElementById('stackBB').value = res || '';
  document.getElementById('stackBBView').value = res ? `${res}BB` : '';
}

/* 선택된 플레이어 정보 가져오기 */
function getSelectedPlayer(){
  const key = document.getElementById('selRoomTable').value;
  const seat = document.getElementById('selSeat').value;
  return findPlayerBySeat(key, seat);
}

/* ===== 데이터 재로드 (Stale-While-Revalidate) ===== */
function reloadSheets(){
  // Step 1: 메모리 캐시가 있으면 즉시 표시 (100ms)
  if (state.typeRows && state.typeRows.length > 0) {
    console.log('🚀 [SWR] 메모리 캐시 즉시 표시:', state.typeRows.length, '행');
    indexTypeRows(state.typeRows);
    fillRoomTables();
    setStatus('준비됨 (백그라운드 갱신 중...)');

    // 캐시된 데이터가 있으면 로딩 오버레이 숨김
    hideLoading();
  } else {
    // 캐시 없으면 로딩 표시
    setStatus('시트 정보 로딩…');
    updateLoading('⏰ 시간 옵션 로드 중...', 'CUE Sheet에서 시간 목록 불러오는 중...');
  }

  // PC 로컬 시간 생성 (HH:mm 형식)
  const now = new Date();
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const clientTime = `${hours}:${minutes}`;

  // Step 2: 백그라운드에서 최신 데이터 로드 (시간 옵션)
  google.script.run.withSuccessHandler(res=>{
    if(res?.ok){
      state.timeCenter = res.center || '';
      fillTimes(res.list||[], res.center||'');
      rebuildFileName();

      if (!state.typeRows || state.typeRows.length === 0) {
        updateLoading('✅ 시간 옵션 완료', `${res.list?.length || 0}개 시간 옵션 로드됨`);
      }
    }
    else {
      toast('시간 목록 로딩 실패: '+(res?.error||'unknown'), false);
    }
  }).getTimeOptions(state.cueId || null, clientTime);

  if (!state.typeRows || state.typeRows.length === 0) {
    updateLoading('👥 플레이어 정보 로드 중...', 'TYPE Sheet에서 플레이어 데이터 불러오는 중...');
  }

  // Step 3: 백그라운드에서 최신 데이터 로드 (플레이어 정보 + 버전 체크)
  const previousCount = state.typeRows?.length || 0;
  const hadCache = state.typeRows && state.typeRows.length > 0;

  google.script.run.withSuccessHandler(res=>{
    if(res?.ok){
      const newCount = res.rows?.length || 0;

      state.typeRows = res.rows||[];

      // 디버깅: KeyPlayer 데이터 확인
      console.log('📊 Type 탭 데이터 로드 완료:', res.rows?.length, '행');
      const keyPlayers = res.rows?.filter(r => r.keyPlayer) || [];
      console.log('⭐ 키 플레이어 발견:', keyPlayers.length, '명');
      keyPlayers.forEach(p => {
        console.log(`  - ${p.seat} ${p.player} (${p.room} Table ${p.tno})`);
      });

      // UI 업데이트
      indexTypeRows(state.typeRows);
      fillRoomTables();

      // 데이터 변경 감지
      if (hadCache && newCount !== previousCount) {
        console.log(`🔄 [SWR] 데이터 변경 감지: ${previousCount}행 → ${newCount}행`);
        toast(`📊 플레이어 정보 업데이트됨 (${newCount}명, ⭐ ${keyPlayers.length}명)`, true);
      } else if (hadCache) {
        console.log(`✅ [SWR] 데이터 변경 없음 (${newCount}행)`);
      }

      setStatus('준비됨');
    }
    else {
      toast('Type 탭 로딩 실패: '+(res?.error||'unknown'), false);
      setStatus('에러');
    }

    // 모든 로딩 완료
    if (!hadCache || !state.typeRows || state.typeRows.length === 0) {
      setTimeout(() => {
        hideLoading();
      }, 500);
    }
  }).getCachedTypeRows(state.typeId || null);  // ✅ 버전 체크 + 30분 캐싱
}

  /* 미리보기(전부 대문자 출력) */
function rebuildPreview(){
  const mode = state.mode;

  // DOM 요소 캐싱
  const els = {
    stackAmt: document.getElementById('stackAmt'),
    stackBB: document.getElementById('stackBB'),
    preview: document.getElementById('preview')
  };

  let body='';

  if(mode===CONSTANTS.MODES.PU){
    computeBB();
    const player = getSelectedPlayer();
    if (!player) { body = ''; }
    else {
      const name = (player.player || '').toUpperCase();
      const country = (player.nat || '').toUpperCase();
      const amt = (els.stackAmt.value||'').toUpperCase();
      const bb = (els.stackBB.value||'').toUpperCase();
      body = `${name} / ${country}\nCURRENT STACK - ${amt} (${bb}BB)`;
    }
  }else if(mode===CONSTANTS.MODES.ELIM){
    const player = getSelectedPlayer();
    if (!player) { body = ''; }
    else {
      const name = (player.player || '').toUpperCase();
      const country = (player.nat || '').toUpperCase();
      body = `${name} / ${country}\nELIMINATED`;
    }
  }else if(mode===CONSTANTS.MODES.L3){
    const player = getSelectedPlayer();
    if (!player) { body = ''; }
    else {
      const name = (player.player || '').toUpperCase();
      const country = (player.nat || '').toUpperCase();
      body = `플레이어 소개\n${name} / ${country}`;
    }
  }
  els.preview.value = body;
}

// 현재 입력 미리보기 생성
function generateCurrentPreview() {
  const mode = state.mode;
  const els = {
    stackAmt: document.getElementById('stackAmt'),
    stackBB: document.getElementById('stackBB')
  };

  let body = '';

  if (mode === CONSTANTS.MODES.PU) {
    computeBB();
    const player = getSelectedPlayer();
    if (player) {
      const name = (player.player || '').toUpperCase();
      const country = (player.nat || '').toUpperCase();
      const amt = (els.stackAmt.value || '').toUpperCase();
      const bb = (els.stackBB.value || '').toUpperCase();
      body = `${name} / ${country}\nCURRENT STACK - ${amt} (${bb}BB)`;
    }
  } else if (mode === CONSTANTS.MODES.ELIM) {
    const player = getSelectedPlayer();
    if (player) {
      const name = (player.player || '').toUpperCase();
      const country = (player.nat || '').toUpperCase();
      body = `${name} / ${country}\nELIMINATED`;
    }
  } else if (mode === CONSTANTS.MODES.L3) {
    const player = getSelectedPlayer();
    if (player) {
      const name = (player.player || '').toUpperCase();
      const country = (player.nat || '').toUpperCase();
      body = `플레이어 소개\n${name} / ${country}`;
    }
  }

  return body;
}

// 미리보기 통합 업데이트
function updateBatchPreview() {
  const previewEl = document.getElementById('preview');
  const previewLabel = document.getElementById('previewLabel');

  if (state.batch.length > 0) {
    // 배치 모드: 배치 전체 내용 + 현재 입력 표시
    const batchContent = state.batch.map(item => item.content).join('\n\n');
    const currentPreview = generateCurrentPreview();

    previewLabel.textContent = `미리보기 (배치 ${state.batch.length}건 + 현재 입력)`;
    previewEl.value = `=== 배치 전송될 내용 (${state.batch.length}건) ===\n\n${batchContent}\n\n=== 현재 입력 (배치에 추가하려면 [➕ 배치에 추가] 클릭) ===\n\n${currentPreview}`;
  } else {
    // 단일 모드
    previewLabel.textContent = '미리보기';
    rebuildPreview();
  }
}

  // ===== Optimistic UI: IndexedDB 동기화 큐 =====
// 목적: 즉시 UI 피드백 + 백그라운드 Sheets 동기화

const SYNC_DB_NAME = 'SoftSenderQueue';
const SYNC_DB_VERSION = 1;
const SYNC_STORE_NAME = 'queue';

// IndexedDB 초기화
async function initSyncDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(SYNC_DB_NAME, SYNC_DB_VERSION);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);

    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(SYNC_STORE_NAME)) {
        const store = db.createObjectStore(SYNC_STORE_NAME, { keyPath: 'id' });
        store.createIndex('status', 'status', { unique: false });
        store.createIndex('timestamp', 'timestamp', { unique: false });
        console.log('✅ IndexedDB 동기화 큐 생성 완료');
      }
    };
  });
}

// 동기화 큐에 추가
async function addToSyncQueue(item) {
  const db = await initSyncDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(SYNC_STORE_NAME, 'readwrite');
    const store = tx.objectStore(SYNC_STORE_NAME);
    const request = store.put(item);

    request.onsuccess = () => {
      console.log(`✅ 큐 추가: ID=${item.id}, 상태=${item.status}`);
      resolve(item.id);
    };
    request.onerror = () => reject(request.error);
  });
}

// 동기화 큐 업데이트
async function updateSyncQueue(id, status, result = null) {
  const db = await initSyncDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(SYNC_STORE_NAME, 'readwrite');
    const store = tx.objectStore(SYNC_STORE_NAME);
    const getRequest = store.get(id);

    getRequest.onsuccess = () => {
      const item = getRequest.result;
      if (item) {
        item.status = status;
        item.result = result;
        item.updatedAt = Date.now();

        const putRequest = store.put(item);
        putRequest.onsuccess = () => {
          console.log(`✅ 큐 업데이트: ID=${id}, 상태=${status}`);
          resolve();
        };
        putRequest.onerror = () => reject(putRequest.error);
      } else {
        reject(new Error(`Item not found: ${id}`));
      }
    };
    getRequest.onerror = () => reject(getRequest.error);
  });
}

// 동기화 큐 조회 (단일)
async function getSyncQueueItem(id) {
  const db = await initSyncDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(SYNC_STORE_NAME, 'readonly');
    const store = tx.objectStore(SYNC_STORE_NAME);
    const request = store.get(id);

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// 동기화 큐 전체 조회
async function getAllSyncQueue() {
  const db = await initSyncDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(SYNC_STORE_NAME, 'readonly');
    const store = tx.objectStore(SYNC_STORE_NAME);
    const request = store.getAll();

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// 실패한 항목 조회
async function getFailedSyncItems() {
  const db = await initSyncDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(SYNC_STORE_NAME, 'readonly');
    const store = tx.objectStore(SYNC_STORE_NAME);
    const index = store.index('status');
    const request = index.getAll('failed');

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

// 동기화 큐 삭제
async function removeSyncQueueItem(id) {
  const db = await initSyncDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(SYNC_STORE_NAME, 'readwrite');
    const store = tx.objectStore(SYNC_STORE_NAME);
    const request = store.delete(id);

    request.onsuccess = () => {
      console.log(`✅ 큐 삭제: ID=${id}`);
      resolve();
    };
    request.onerror = () => reject(request.error);
  });
}

// 오래된 항목 정리 (24시간 이상)
async function cleanupOldSyncQueue() {
  const items = await getAllSyncQueue();
  const now = Date.now();
  const cutoff = 24 * 60 * 60 * 1000; // 24시간

  for (const item of items) {
    if (item.status === 'success' && (now - item.timestamp > cutoff)) {
      await removeSyncQueueItem(item.id);
    }
  }

  console.log('✅ 동기화 큐 정리 완료');
}

// 앱 시작 시 초기화
(async function() {
  try {
    await initSyncDB();
    await cleanupOldSyncQueue();
    console.log('✅ 동기화 시스템 초기화 완료');
  } catch(e) {
    console.error('❌ 동기화 시스템 초기화 실패:', e);
  }
})();

  // ===== Optimistic UI: 즉시 피드백 + 백그라운드 동기화 =====

// 재시도 설정
const RETRY_MAX_ATTEMPTS = 3;
const RETRY_BASE_DELAY = 2000; // 2초

// Optimistic UI로 전송 (즉시 피드백)
async function sendWithOptimisticUI(payload) {
  const tempId = Date.now();

  try {
    // 1. 즉시 UI 피드백 (0.1초 이내)
    toast('✅ 전송 중...', true);
    showLoading('서버 전송 중...', '백그라운드 동기화');

    // 2. 로컬 큐에 추가
    await addToSyncQueue({
      id: tempId,
      payload: payload,
      status: 'pending',
      timestamp: Date.now(),
      attempts: 0
    });

    // 3. 백그라운드 동기화 시작
    syncToServer(tempId, payload);

    // 4. 즉시 다음 작업 허용 (사용자는 기다리지 않음)
    setTimeout(() => {
      hideLoading();
      toast('📤 백그라운드 동기화 중...', true);
    }, 300);

  } catch(e) {
    console.error('❌ Optimistic UI 실패:', e);
    hideLoading();
    toast('❌ 전송 실패 - 재시도하세요', false);
  }
}

// 서버 동기화 (비동기)
function syncToServer(id, payload, attempt = 1) {
  console.log(`🔄 서버 동기화 시작: ID=${id}, 시도=${attempt}/${RETRY_MAX_ATTEMPTS}`);

  google.script.run
    .withSuccessHandler(async (res) => {
      if (res.ok) {
        // 성공 - 진행 로그 표시
        if (res.logs && res.logs.length > 0) {
          console.log('📋 [서버 진행 로그]:');
          res.logs.forEach(log => {
            console.log(`  ${log.step} ${log.message}${log.duration ? ` (${log.duration}ms)` : ''}`);
          });
        }

        await updateSyncQueue(id, 'success', res);
        console.log(`✅ 동기화 성공: ${res.filename} (총 ${(res.totalTime/1000).toFixed(1)}초)`);
        toast(`✅ 저장 완료: ${res.filename} (${(res.totalTime/1000).toFixed(1)}초)`, true);

        // 성공한 항목은 10초 후 삭제
        setTimeout(() => removeSyncQueueItem(id), 10000);
      } else {
        // 서버 에러 - 에러 로그도 표시
        if (res.logs && res.logs.length > 0) {
          console.log('📋 [서버 진행 로그 (에러 발생)]:');
          res.logs.forEach(log => {
            console.log(`  ${log.step} ${log.message}${log.duration ? ` (${log.duration}ms)` : ''}`);
          });
        }

        console.error(`⚠️ 서버 에러: ${res.error}`);
        await handleSyncFailure(id, payload, attempt, res.error);
      }
    })
    .withFailureHandler(async (err) => {
      // 네트워크 에러
      console.error(`❌ 네트워크 에러:`, err);
      await handleSyncFailure(id, payload, attempt, String(err));
    })
    .updateVirtual(payload);
}

// 동기화 실패 처리
async function handleSyncFailure(id, payload, attempt, errorMsg) {
  if (attempt < RETRY_MAX_ATTEMPTS) {
    // 재시도
    await updateSyncQueue(id, 'retrying', { attempt, error: errorMsg });

    const delay = RETRY_BASE_DELAY * Math.pow(2, attempt - 1); // 지수 백오프
    console.log(`🔄 ${delay/1000}초 후 재시도 (${attempt + 1}/${RETRY_MAX_ATTEMPTS})`);

    toast(`🔄 재시도 ${attempt}/${RETRY_MAX_ATTEMPTS} 대기 중...`, true);

    setTimeout(() => {
      syncToServer(id, payload, attempt + 1);
    }, delay);
  } else {
    // 최종 실패
    await updateSyncQueue(id, 'failed', {
      attempt,
      error: errorMsg,
      finalError: '최대 재시도 횟수 초과'
    });

    console.error(`❌ 최종 실패: ID=${id}`);
    toast(`❌ 전송 실패 (ID: ${id}) - 수동 재전송 필요`, false);

    // 실패 알림 UI 표시
    showFailedSyncNotification(id, payload);
  }
}

// 실패한 동기화 알림 UI
function showFailedSyncNotification(id, payload) {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--error-bg);
    color: var(--error-color);
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 10000;
    max-width: 90%;
    text-align: center;
  `;

  notification.innerHTML = `
    <div style="margin-bottom: 8px;">
      ⚠️ 전송 실패 (ID: ${id})
    </div>
    <button onclick="retrySyncManually(${id})" style="
      background: var(--primary);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 8px;
    ">
      🔄 재시도
    </button>
    <button onclick="dismissFailedSync(${id}, this.parentElement.parentElement)" style="
      background: #666;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    ">
      무시
    </button>
  `;

  document.body.appendChild(notification);

  // 30초 후 자동 제거
  setTimeout(() => {
    if (notification.parentElement) {
      notification.remove();
    }
  }, 30000);
}

// 수동 재시도
window.retrySyncManually = async function(id) {
  const item = await getSyncQueueItem(id);
  if (item) {
    toast('🔄 재시도 중...', true);
    syncToServer(id, item.payload, 1);
  } else {
    toast('❌ 항목을 찾을 수 없습니다', false);
  }
};

// 실패 알림 무시
window.dismissFailedSync = async function(id, element) {
  await removeSyncQueueItem(id);
  element.remove();
  toast('알림 제거됨', true);
};

// 앱 시작 시 실패한 항목 복구
(async function() {
  try {
    const failedItems = await getFailedSyncItems();
    if (failedItems.length > 0) {
      console.log(`⚠️ 실패한 동기화 ${failedItems.length}건 발견`);

      // 사용자에게 알림
      toast(`⚠️ 실패한 전송 ${failedItems.length}건 - 재시도 가능`, false);

      // 각 실패 항목에 대한 알림 표시
      failedItems.forEach(item => {
        showFailedSyncNotification(item.id, item.payload);
      });
    }
  } catch(e) {
    console.error('❌ 실패 항목 복구 실패:', e);
  }
})();

  /* ===== 배치 빌더 (스마트 통합) ===== */

// 스마트 전송 버튼 업데이트
function updateSendButton() {
  const btnSend = document.getElementById('btnSend');
  const btnAddToBatch = document.getElementById('btnAddToBatch');
  const batchSection = document.getElementById('batchSection');

  if (state.batch.length > 0) {
    // 배치 모드
    btnSend.innerHTML = `📤 배치 전송 (${state.batch.length}건)`;
    batchSection.style.display = 'block';
  } else {
    // 단일 모드
    btnSend.innerHTML = '전송';
    batchSection.style.display = 'none';
  }

  // 배치 추가 버튼 항상 표시
  btnAddToBatch.style.display = 'block';
}

// 배치에 추가
function addToBatch() {
  const preview = document.getElementById('preview').value.trim();

  if (!preview) {
    toast('미리보기가 비어있습니다. 먼저 플레이어를 선택하고 정보를 입력하세요.', false);
    return;
  }

  const player = getSelectedPlayer();
  const mode = state.mode;

  state.batch.push({
    mode,
    player: player?.player || 'Unknown',
    seat: player?.seat || '',
    nat: player?.nat || '',
    keyPlayer: player?.keyPlayer || false,
    content: preview
  });

  renderBatchList();
  updateBatchPreview();
  updateSendButton();
  toast(`✅ 배치에 추가됨 (${state.batch.length}건)`, true);

  moveToNextSeat();
}

// 배치 리스트 렌더링
function renderBatchList() {
  const list = document.getElementById('batchList');

  if (state.batch.length === 0) {
    list.innerHTML = '';
    document.getElementById('batchCount').textContent = '0';
    return;
  }

  list.innerHTML = '';

  state.batch.forEach((item, idx) => {
    const div = document.createElement('div');
    div.style.cssText = 'background:var(--panel); padding:14px; border-radius:12px; display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; min-height:44px;';

    const keyPlayerIcon = item.keyPlayer ? ' ⭐' : '';

    div.innerHTML = `
      <div style="flex:1; min-width:0;">
        <div style="font-weight:600; font-size:0.95em;">
          ${idx + 1}. ${item.seat} ${item.player}${keyPlayerIcon}
          <span style="color:var(--accent); margin-left:8px; font-size:0.85em;">[${item.mode}]</span>
        </div>
        <div class="muted" style="font-size:0.8em; margin-top:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
          ${item.content.replace(/\n/g, ' · ').substring(0, 60)}...
        </div>
      </div>
      <button class="btn ghost" data-idx="${idx}" style="padding:10px 16px; height:auto; font-size:0.85em; margin-left:10px; flex-shrink:0;">
        삭제
      </button>
    `;

    div.querySelector('button').addEventListener('click', (e) => {
      const idx = parseInt(e.target.dataset.idx);
      state.batch.splice(idx, 1);
      renderBatchList();
      updateBatchPreview();
      updateSendButton();
      toast('항목 삭제됨', true);
    });

    list.appendChild(div);
  });

  document.getElementById('batchCount').textContent = state.batch.length;
}

// 다음 좌석으로 자동 이동
function moveToNextSeat() {
  const key = document.getElementById('selRoomTable').value;
  const seat = document.getElementById('selSeat').value;
  const arr = state.byRoomTable[key] || [];

  const seats = [...new Set(arr.map(r => normSeat(r.seat)))]
    .sort((a,b) => Number(a.replace('#','')) - Number(b.replace('#','')));

  const currentIndex = seats.indexOf(seat);

  if (currentIndex >= 0 && currentIndex < seats.length - 1) {
    const nextSeat = seats[currentIndex + 1];
    document.getElementById('selSeat').value = nextSeat;
    applyPickFromSeat();
    rebuildPreview();
    rebuildFileName();
  } else {
    if (seats.length > 0) {
      document.getElementById('selSeat').value = seats[0];
      applyPickFromSeat();
      rebuildPreview();
      rebuildFileName();
    }
  }
}

// 배치 전송
function sendBatch() {
  if (state.batch.length === 0) {
    toast('배치가 비어있습니다.', false);
    return;
  }

  const jBlock = state.batch.map(item => item.content).join('\n\n');

  const autoNow = document.getElementById('chkAuto').checked;
  const picked = document.getElementById('selTime').value;

  // PC 로컬 시간 사용 (autoNow일 때)
  let timeStr, hhmm;
  if (autoNow) {
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    timeStr = `${hours}:${minutes}`;
    hhmm = `${hours}${minutes}`;
  } else {
    timeStr = picked;
    hhmm = hhmmFromTimeStr(timeStr);
  }

  const key = document.getElementById('selRoomTable').value;
  const tno = key ? key.split('|')[1] : '';

  // 배치 파일명 생성 데이터
  const modeData = { count: state.batch.length };

  const payload = {
    autoNow,
    pickedTime: picked,
    tz: state.tz,
    kind: 'BATCH',
    eFix: '미완료',
    gFix: 'SOFT',
    playerName: 'Batch',
    tableNo: tno,
    hhmm,
    modeData,
    jBlock,
    cueId: state.cueId || undefined
  };

  // 로딩 시작
  if (!LoadingManager.start('SEND_BATCH', '배치 전송 중...', `${state.batch.length}건 데이터를 전송합니다...`)) {
    return;
  }

  google.script.run
    .withSuccessHandler(res => {
      if (!res?.ok) {
        LoadingManager.error('전송 실패: ' + (res?.error || 'unknown'));
        return;
      }

      LoadingManager.success(`✅ ${res.filename} - 행 ${res.row}(${res.time}) 저장 완료 (${state.batch.length}건, SC${String(res.scNumber).padStart(3, '0')})`);

      state.batch = [];
      renderBatchList();
      updateBatchPreview();
      updateSendButton();
    })
    .withFailureHandler(err => {
      LoadingManager.error('서버 오류: ' + (err?.message || err));
    })
    .updateVirtual(payload);
}

/* 스마트 전송 (단일/배치 자동 감지) */
function send(){
  // 배치 모드인지 확인
  if (state.batch.length > 0) {
    sendBatch();
    return;
  }

  // 단일 전송
  sendSingle();
}

// 단일 전송
function sendSingle() {
  const autoNow = document.getElementById('chkAuto').checked;
  const picked  = document.getElementById('selTime').value;
  const jBlock  = generateCurrentPreview(); // 배치 미리보기 제외

  if(!jBlock){ toast('미리보기 내용이 비었습니다.', false); return; }
  if(state.mode===CONSTANTS.MODES.PU){
    if(!parseIntClean(document.getElementById('stackAmt').value) || !parseIntClean(document.getElementById('bigBlind').value)){
      toast('칩스택/빅블을 입력하세요.', false); return;
    }
  }

  // 파일명 생성에 필요한 데이터 수집
  const player = getSelectedPlayer();
  const key = document.getElementById('selRoomTable').value;
  const tno = key ? key.split('|')[1] : '';

  // PC 로컬 시간 사용 (autoNow일 때)
  let timeStr, hhmm;
  if (autoNow) {
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    timeStr = `${hours}:${minutes}`;
    hhmm = `${hours}${minutes}`;
  } else {
    timeStr = picked;
    hhmm = hhmmFromTimeStr(timeStr);
  }

  let modeData = {};
  if (state.mode === CONSTANTS.MODES.PU) {
    const chipCount = parseIntClean(document.getElementById('stackAmt').value);
    const bb = document.getElementById('stackBB').value;
    modeData = { chipCount, bb };
  } else if (state.mode === CONSTANTS.MODES.ELIM) {
    modeData = {};
  } else if (state.mode === CONSTANTS.MODES.L3) {
    modeData = { profileType: 'Profile' };
  }

  // ===== Optimistic UI 적용: 즉시 피드백 =====
  const payload = {
    autoNow,
    pickedTime: picked,
    tz: state.tz,
    kind: state.mode,
    eFix: '미완료',
    gFix: 'SOFT',
    playerName: player ? player.player : 'Player',
    tableNo: tno,
    hhmm,
    modeData,
    jBlock,
    cueId: state.cueId || undefined
  };

  // 로딩 시작
  if (!LoadingManager.start('SEND_SINGLE', '단일 전송 중...', `${payload.playerName} 데이터를 전송합니다...`)) {
    return;
  }

  google.script.run.withSuccessHandler(res=>{
    if(!res?.ok){
      LoadingManager.error('전송 실패: '+(res?.error||'unknown'));
      return;
    }
    LoadingManager.success(`✅ ${res.filename} - 행 ${res.row}(${res.time}) 저장 완료 (SC${String(res.scNumber).padStart(3, '0')})`);
  }).withFailureHandler(err=>{
    LoadingManager.error('서버 오류: '+(err?.message||err));
  }).updateVirtual(payload);
}

  // 모드 변경
function setMode(m){
  state.mode = m;
  document.getElementById('tabPU').classList.toggle('active', m===CONSTANTS.MODES.PU);
  document.getElementById('tabELIM').classList.toggle('active', m===CONSTANTS.MODES.ELIM);
  document.getElementById('tabL3').classList.toggle('active', m===CONSTANTS.MODES.L3);

  document.getElementById('panelPU').style.display   = (m===CONSTANTS.MODES.PU)?CONSTANTS.DISPLAY.BLOCK:CONSTANTS.DISPLAY.NONE;
  document.getElementById('panelELIM').style.display = (m===CONSTANTS.MODES.ELIM)?CONSTANTS.DISPLAY.BLOCK:CONSTANTS.DISPLAY.NONE;
  document.getElementById('panelL3').style.display   = (m===CONSTANTS.MODES.L3)?CONSTANTS.DISPLAY.BLOCK:CONSTANTS.DISPLAY.NONE;

  // 배치 작업 중 모드 변경 시 피드백
  if (state.batch.length > 0) {
    const modeNames = {
      PU: '플레이어 업데이트',
      ELIM: '플레이어 탈락',
      L3: '플레이어 소개'
    };
    toast(`⚠️ 모드 변경: ${modeNames[m]}`, true);
  }

  rebuildPreview();
  rebuildFileName();
  updateSendButton();  // 모드 변경 시 버튼 상태 업데이트
}

  // 전역 변수: setInterval ID 저장 (중복 방지)
let keepAliveInterval = null;
let isInitialized = false;

function init(){
  // 중복 초기화 방지
  if (isInitialized) {
    console.warn('⚠️ init() 이미 실행됨 - 중복 호출 차단');
    return;
  }
  isInitialized = true;

  // 로딩 오버레이 표시
  showLoading('🔧 초기화 중...', '서버 연결 중...');

  // 서버에서 부트스트랩 정보 로드 (사용자별 저장된 Sheet ID 포함)
  google.script.run.withSuccessHandler(info=>{
    updateLoading('✅ 서버 연결 완료', `사용자: ${info?.userEmail || 'Anonymous'}`);

    state.tz = info?.tz || 'Asia/Seoul';

    // 서버에서 로드한 Sheet ID를 입력 필드에 설정
    const serverCueId = info?.cueId || '';
    const serverTypeId = info?.typeId || '';

    updateLoading('📥 설정 로드 중...', `CUE ID: ${serverCueId ? '사용자 설정' : '기본값'}\nTYPE ID: ${serverTypeId ? '사용자 설정' : '기본값'}`);

    if (serverCueId) {
      document.getElementById('cueId').value = serverCueId;
      localStorage.setItem(LS_KEYS.CUE, serverCueId);
    }
    if (serverTypeId) {
      document.getElementById('typeId').value = serverTypeId;
      localStorage.setItem(LS_KEYS.TYPE, serverTypeId);
    }

    state.cueId = serverCueId;
    state.typeId = serverTypeId;
    renderIdsHint();

    document.getElementById('footerInfo').textContent =
      `로그인: ${info?.userEmail || 'Anonymous'}  |  기본 CUE: ${info?.defaultCueId?.substring(0, 8)}...  |  TZ=${state.tz}`;

    updateLoading('📊 데이터 로드 중...', '시간 옵션 & 플레이어 정보 로딩...');

    // Sheet ID 로드 후 데이터 로드
    reloadSheets();
  }).withFailureHandler(err => {
    hideLoading();
    toast('❌ 초기화 실패: ' + (err?.message || err), false);
    setStatus('에러');
  }).getBootstrap();

  // localStorage에서 임시 로드 (서버 응답 전 빠른 표시용)
  loadIdsFromLocal();

  document.getElementById('btnSaveIds').onclick = saveIds;
  document.getElementById('btnClearIds').onclick = clearIds;

  // Sheet ID 입력 필드 자동 저장 (debounce 적용)
  const debouncedAutoSave = debounce(autoSaveIds, 1000); // 1초 대기 후 저장
  document.getElementById('cueId').addEventListener('input', debouncedAutoSave);
  document.getElementById('typeId').addEventListener('input', debouncedAutoSave);

  document.getElementById('tabPU').onclick   = ()=>setMode(CONSTANTS.MODES.PU);
  document.getElementById('tabELIM').onclick = ()=>setMode(CONSTANTS.MODES.ELIM);
  document.getElementById('tabL3').onclick   = ()=>setMode(CONSTANTS.MODES.L3);
  document.getElementById('btnSend').onclick = send;

  // 배치 추가 버튼
  document.getElementById('btnAddToBatch').addEventListener('click', addToBatch);

  // 배치 전체 삭제
  document.getElementById('btnClearBatch').addEventListener('click', () => {
    if (state.batch.length === 0) return;

    if (confirm(`${state.batch.length}개 항목을 모두 삭제하시겠습니까?`)) {
      state.batch = [];
      renderBatchList();
      updateBatchPreview();
      updateSendButton();
      toast('배치 초기화됨', true);
    }
  });

  // 키보드 단축키: Ctrl+B
  document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
      e.preventDefault();
      if (state.batch.length > 0 || document.getElementById('btnAddToBatch').style.display !== 'none') {
        addToBatch();
      }
    }
  });

  document.getElementById('selRoomTable').addEventListener('change', fillSeats);
  document.getElementById('selSeat').addEventListener('change', applyPickFromSeat);

  // 디바운싱된 미리보기 갱신
  const debouncedRebuild = debounce(() => {
    rebuildPreview();
    rebuildFileName();
  }, CONSTANTS.DEBOUNCE_DELAY);

  const stackAmt = document.getElementById('stackAmt');
  stackAmt.addEventListener('input', ()=>{ formatInputWithComma(stackAmt); computeBB(); debouncedRebuild(); });
  const bigBlind = document.getElementById('bigBlind');
  bigBlind.addEventListener('input', ()=>{ formatInputWithComma(bigBlind); computeBB(); debouncedRebuild(); });

  setMode(CONSTANTS.MODES.PU);

  // Priority 1: Session Keep-Alive (Cold Start 제거)
  startSessionKeepAlive();
}

// 세션 유지 함수 (4분마다 더미 호출)
function startSessionKeepAlive() {
  // 기존 interval 정리 (중복 방지)
  if (keepAliveInterval) {
    console.log('🧹 [Keep-Alive] 기존 interval 정리');
    clearInterval(keepAliveInterval);
    keepAliveInterval = null;
  }

  console.log('🔄 [Keep-Alive] 세션 유지 시작');

  keepAliveInterval = setInterval(() => {
    const timestamp = new Date().toLocaleTimeString('ko-KR');
    console.log(`🔄 [Keep-Alive] 세션 유지 중... (${timestamp})`);

    google.script.run
      .withSuccessHandler(() => {
        console.log(`✅ [Keep-Alive] 세션 유지 성공 (${timestamp})`);
      })
      .withFailureHandler((err) => {
        console.warn(`⚠️ [Keep-Alive] 세션 유지 실패: ${err}`);
      })
      .getBootstrap(); // 가벼운 함수 호출
  }, 4 * 60 * 1000); // 4분마다 (Google 5분 타임아웃 전)
}

// 페이지 종료 시 리소스 정리
window.addEventListener('beforeunload', () => {
  if (keepAliveInterval) {
    console.log('🧹 [Clean-Up] Keep-Alive interval 정리');
    clearInterval(keepAliveInterval);
    keepAliveInterval = null;
  }
});

window.addEventListener('load', init);

</script>
</body>
</html>
